package clients

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"math/big"
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/programs/token"
	"github.com/gagliardetto/solana-go/rpc"
	"github.com/gagliardetto/solana-go/rpc/ws"
	"github.com/shopspring/decimal"
	
	x402types "github.com/vitwit/x402/types"
)

// SolanaClient handles Solana blockchain operations
type SolanaClient struct {
	client     *rpc.Client
	wsClient   *ws.Client
	network    x402types.Network
	rpcURL     string
	wsURL      string
	timeout    time.Duration
	commitment rpc.CommitmentType
}

// SolanaTokenAccount represents a Solana token account
type SolanaTokenAccount struct {
	Account   solana.PublicKey `json:"account"`
	Mint      solana.PublicKey `json:"mint"`
	Owner     solana.PublicKey `json:"owner"`
	Amount    uint64           `json:"amount"`
	Decimals  uint8            `json:"decimals"`
	Frozen    bool             `json:"frozen"`
}

// SolanaTransactionInfo contains detailed transaction information
type SolanaTransactionInfo struct {
	Signature          string                  `json:"signature"`
	Slot               uint64                  `json:"slot"`
	BlockTime          *int64                  `json:"blockTime"`
	ConfirmationStatus string                  `json:"confirmationStatus"`
	Err                interface{}             `json:"err"`
	Meta               *rpc.TransactionMeta    `json:"meta"`
	Transaction        map[string]interface{}  `json:"transaction"`
	Version            interface{}             `json:"version"`
}

// NewSolanaClient creates a new Solana client instance
func NewSolanaClient(network x402types.Network, rpcURL, wsURL string) (*SolanaClient, error) {
	if !network.IsSolana() {
		return nil, &x402types.X402Error{
			Code:    x402types.ErrUnsupportedNetwork,
			Message: fmt.Sprintf("network %s is not a Solana network", network),
		}
	}
	
	// Create RPC client
	client := rpc.New(rpcURL)
	
	var wsClient *ws.Client
	if wsURL != "" {
		var err error
		wsClient, err = ws.Connect(context.Background(), wsURL)
		if err != nil {
			// WebSocket connection is optional, continue without it
			wsClient = nil
		}
	}
	
	solanaClient := &SolanaClient{
		client:     client,
		wsClient:   wsClient,
		network:    network,
		rpcURL:     rpcURL,
		wsURL:      wsURL,
		timeout:    30 * time.Second,
		commitment: rpc.CommitmentFinalized,
	}
	
	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), solanaClient.timeout)
	defer cancel()
	
	_, err := client.GetHealth(ctx)
	if err != nil {
		return nil, &x402types.X402Error{
			Code:    x402types.ErrNetworkError,
			Message: fmt.Sprintf("failed to connect to Solana node: %v", err),
		}
	}
	
	return solanaClient, nil
}

// VerifyPayment verifies a Solana payment
func (c *SolanaClient) VerifyPayment(
	ctx context.Context,
	payload *x402types.PaymentPayload,
	requirements *x402types.PaymentRequirements,
) (*x402types.VerificationResult, error) {
	if payload.Solana == nil {
		return &x402types.VerificationResult{
			Valid: false,
			Error: "Solana payment data is required",
		}, nil
	}
	
	// Parse signature
	signature, err := solana.SignatureFromBase58(payload.Solana.Signature)
	if err != nil {
		return &x402types.VerificationResult{
			Valid: false,
			Error: fmt.Sprintf("invalid signature format: %v", err),
		}, nil
	}
	
	// Get transaction details
	txInfo, err := c.client.GetTransaction(
		ctx,
		signature,
		&rpc.GetTransactionOpts{
			Encoding:   solana.EncodingJSON,
			Commitment: c.commitment,
		},
	)
	if err != nil {
		return &x402types.VerificationResult{
			Valid: false,
			Error: fmt.Sprintf("failed to get transaction: %v", err),
		}, nil
	}
	
	if txInfo == nil {
		return &x402types.VerificationResult{
			Valid: false,
			Error: "transaction not found",
		}, nil
	}
	
	// Check if transaction was successful
	if txInfo.Meta != nil && txInfo.Meta.Err != nil {
		return &x402types.VerificationResult{
			Valid: false,
			Error: fmt.Sprintf("transaction failed: %v", txInfo.Meta.Err),
		}, nil
	}
	
	result := &x402types.VerificationResult{
		Valid:         true,
		Timestamp:     &payload.Timestamp,
		Confirmations: 0, // Will be calculated below
	}
	
	// Calculate confirmations
	if payload.Solana.Slot > 0 {
		latestSlot, err := c.client.GetSlot(ctx, c.commitment)
		if err == nil {
			result.Confirmations = int(latestSlot - payload.Solana.Slot)
		}
	}
	
	// Verify payment based on token type
	if requirements.Token.Standard == x402types.TokenStandardSPL {
		// SPL token transfer verification
		isValid, amount, err := c.verifySPLTransfer(ctx, txInfo, requirements)
		if err != nil {
			result.Valid = false
			result.Error = fmt.Sprintf("SPL verification failed: %v", err)
			return result, nil
		}
		
		result.Valid = isValid
		result.Amount = amount
		result.Token = requirements.Token.Address
		
	} else if requirements.Token.Standard == x402types.TokenStandardNative {
		// Native SOL transfer verification
		isValid, amount, err := c.verifySOLTransfer(txInfo, requirements)
		if err != nil {
			result.Valid = false
			result.Error = fmt.Sprintf("SOL transfer verification failed: %v", err)
			return result, nil
		}
		
		result.Valid = isValid
		result.Amount = amount
		result.Token = "SOL"
	}
	
	// Set recipient and sender
	result.Recipient = payload.Recipient
	result.Sender = payload.Sender
	
	// Additional validations
	if result.Valid {
		// Check if payment meets amount requirements
		if !c.verifyAmount(result.Amount, requirements.Amount, requirements.Scheme) {
			result.Valid = false
			result.Error = "payment amount does not meet requirements"
		}
		
		// Check deadline if specified
		if requirements.Deadline != nil && payload.Timestamp.After(*requirements.Deadline) {
			result.Valid = false
			result.Error = "payment deadline exceeded"
		}
	}
	
	return result, nil
}

// CreateTransfer creates a Solana transfer transaction
func (c *SolanaClient) CreateTransfer(
	ctx context.Context,
	fromKeypair solana.PrivateKey,
	toAddress solana.PublicKey,
	amount uint64,
	mint *solana.PublicKey,
) (*solana.Transaction, error) {
	// Get recent blockhash
	recent, err := c.client.GetRecentBlockhash(ctx, c.commitment)
	if err != nil {
		return nil, fmt.Errorf("failed to get recent blockhash: %w", err)
	}
	
	var instructions []solana.Instruction
	
	if mint != nil {
		// SPL token transfer
		fromTokenAccount, err := c.getOrCreateTokenAccount(ctx, fromKeypair.PublicKey(), *mint)
		if err != nil {
			return nil, fmt.Errorf("failed to get from token account: %w", err)
		}
		
		toTokenAccount, err := c.getOrCreateTokenAccount(ctx, toAddress, *mint)
		if err != nil {
			return nil, fmt.Errorf("failed to get to token account: %w", err)
		}
		
		// Create transfer instruction
		transferInstruction := token.NewTransferInstruction(
			amount,
			fromTokenAccount,
			toTokenAccount,
			fromKeypair.PublicKey(),
			[]solana.PublicKey{},
		).Build()
		
		instructions = append(instructions, transferInstruction)
		
	} else {
		// Native SOL transfer
		transferInstruction := solana.NewTransferInstruction(
			amount,
			fromKeypair.PublicKey(),
			toAddress,
		).Build()
		
		instructions = append(instructions, transferInstruction)
	}
	
	// Create transaction
	tx, err := solana.NewTransaction(
		instructions,
		recent.Value.Blockhash,
		solana.TransactionPayer(fromKeypair.PublicKey()),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create transaction: %w", err)
	}
	
	// Sign transaction
	_, err = tx.Sign(
		func(key solana.PublicKey) *solana.PrivateKey {
			if key.Equals(fromKeypair.PublicKey()) {
				return &fromKeypair
			}
			return nil
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to sign transaction: %w", err)
	}
	
	return tx, nil
}

// SendTransaction broadcasts a signed transaction
func (c *SolanaClient) SendTransaction(ctx context.Context, tx *solana.Transaction) (string, error) {
	signature, err := c.client.SendTransactionWithOpts(
		ctx,
		tx,
		false,
		rpc.CommitmentProcessed,
	)
	if err != nil {
		return "", fmt.Errorf("failed to send transaction: %w", err)
	}
	
	return signature.String(), nil
}

// WaitForConfirmation waits for transaction confirmation
func (c *SolanaClient) WaitForConfirmation(
	ctx context.Context,
	signature string,
	requiredConfirmations int,
) (*x402types.SettlementResult, error) {
	sig, err := solana.SignatureFromBase58(signature)
	if err != nil {
		return nil, fmt.Errorf("invalid signature: %w", err)
	}
	
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()
	
	for {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		case <-ticker.C:
			// Check signature status
			statuses, err := c.client.GetSignatureStatuses(
				ctx,
				false,
				sig,
			)
			if err != nil {
				continue
			}
			
			if len(statuses.Value) == 0 || statuses.Value[0] == nil {
				continue
			}
			
			status := statuses.Value[0]
			
			// Check if transaction failed
			if status.Err != nil {
				return &x402types.SettlementResult{
					Success:         false,
					TransactionHash: signature,
					Error:           fmt.Sprintf("transaction failed: %v", status.Err),
					Timestamp:       time.Now(),
				}, nil
			}
			
			// Check confirmations
			if status.Confirmations != nil && int(*status.Confirmations) >= requiredConfirmations {
				// Get slot for block number
				var slot uint64
				if status.Slot != nil {
					slot = *status.Slot
				}
				
				return &x402types.SettlementResult{
					Success:         true,
					TransactionHash: signature,
					BlockNumber:     slot,
					Confirmations:   int(*status.Confirmations),
					Timestamp:       time.Now(),
				}, nil
			}
		}
	}
}

// Helper methods

func (c *SolanaClient) verifySPLTransfer(
	ctx context.Context,
	txInfo *rpc.GetTransactionResult,
	requirements *x402types.PaymentRequirements,
) (bool, *decimal.Decimal, error) {
	if txInfo.Meta == nil {
		return false, nil, fmt.Errorf("transaction meta is nil")
	}
	
	// Parse mint address
	mintAddress, err := solana.PublicKeyFromBase58(requirements.Token.Address)
	if err != nil {
		return false, nil, fmt.Errorf("invalid mint address: %w", err)
	}
	
	// Parse recipient address
	recipientAddress, err := solana.PublicKeyFromBase58(requirements.Recipient)
	if err != nil {
		return false, nil, fmt.Errorf("invalid recipient address: %w", err)
	}
	
	// Check token balances from pre/post token balances
	if txInfo.Meta.PreTokenBalances == nil || txInfo.Meta.PostTokenBalances == nil {
		return false, nil, fmt.Errorf("token balance information not available")
	}
	
	// Find recipient's token account and calculate difference
	for i, postBalance := range txInfo.Meta.PostTokenBalances {
		if postBalance.Mint.Equals(mintAddress) &&
			postBalance.Owner.Equals(recipientAddress) {
			
			// Find corresponding pre-balance
			var preAmount uint64 = 0
			for _, preBalance := range txInfo.Meta.PreTokenBalances {
				if preBalance.AccountIndex == postBalance.AccountIndex {
					preAmount = preBalance.UITokenAmount.Amount
					break
				}
			}
			
			// Calculate transfer amount
			postAmount := postBalance.UITokenAmount.Amount
			if postAmount > preAmount {
				transferAmount := postAmount - preAmount
				
				// Convert to decimal with proper decimals
				amount := decimal.NewFromBigInt(
					new(big.Int).SetUint64(transferAmount),
					-int32(requirements.Token.Decimals),
				)
				
				return true, &amount, nil
			}
		}
	}
	
	return false, nil, fmt.Errorf("no matching SPL transfer found")
}

func (c *SolanaClient) verifySOLTransfer(
	txInfo *rpc.GetTransactionResult,
	requirements *x402types.PaymentRequirements,
) (bool, *decimal.Decimal, error) {
	if txInfo.Meta == nil {
		return false, nil, fmt.Errorf("transaction meta is nil")
	}
	
	// Parse recipient address
	recipientAddress, err := solana.PublicKeyFromBase58(requirements.Recipient)
	if err != nil {
		return false, nil, fmt.Errorf("invalid recipient address: %w", err)
	}
	
	// Find recipient in account keys and check balance change
	if txInfo.Transaction == nil {
		return false, nil, fmt.Errorf("transaction data is nil")
	}
	
	// Parse transaction to get account keys
	txData, ok := txInfo.Transaction.(map[string]interface{})
	if !ok {
		return false, nil, fmt.Errorf("invalid transaction format")
	}
	
	message, ok := txData["message"].(map[string]interface{})
	if !ok {
		return false, nil, fmt.Errorf("invalid transaction message format")
	}
	
	accountKeys, ok := message["accountKeys"].([]interface{})
	if !ok {
		return false, nil, fmt.Errorf("invalid account keys format")
	}
	
	// Find recipient account index
	recipientIndex := -1
	for i, key := range accountKeys {
		keyStr, ok := key.(string)
		if !ok {
			continue
		}
		
		keyPubkey, err := solana.PublicKeyFromBase58(keyStr)
		if err != nil {
			continue
		}
		
		if keyPubkey.Equals(recipientAddress) {
			recipientIndex = i
			break
		}
	}
	
	if recipientIndex == -1 {
		return false, nil, fmt.Errorf("recipient not found in transaction")
	}
	
	// Check balance change
	if len(txInfo.Meta.PreBalances) <= recipientIndex || len(txInfo.Meta.PostBalances) <= recipientIndex {
		return false, nil, fmt.Errorf("balance information not available")
	}
	
	preBalance := txInfo.Meta.PreBalances[recipientIndex]
	postBalance := txInfo.Meta.PostBalances[recipientIndex]
	
	if postBalance > preBalance {
		transferAmount := postBalance - preBalance
		
		// Convert lamports to SOL (9 decimals)
		amount := decimal.NewFromBigInt(
			new(big.Int).SetUint64(transferAmount),
			-9, // SOL has 9 decimals
		)
		
		return true, &amount, nil
	}
	
	return false, nil, fmt.Errorf("no SOL transfer to recipient found")
}

func (c *SolanaClient) verifyAmount(
	actualAmount *decimal.Decimal,
	requiredAmount *x402types.Amount,
	scheme x402types.PaymentScheme,
) bool {
	if actualAmount == nil || requiredAmount == nil {
		return false
	}
	
	switch scheme {
	case x402types.SchemeExact:
		if requiredAmount.Value == nil {
			return false
		}
		return actualAmount.Equal(*requiredAmount.Value)
		
	case x402types.SchemeRange:
		if requiredAmount.Min == nil || requiredAmount.Max == nil {
			return false
		}
		return actualAmount.GreaterThanOrEqual(*requiredAmount.Min) &&
			actualAmount.LessThanOrEqual(*requiredAmount.Max)
			
	case x402types.SchemeAny:
		// Any positive amount is acceptable
		return actualAmount.IsPositive()
		
	default:
		return false
	}
}

// GetTokenInfo retrieves information about an SPL token
func (c *SolanaClient) GetTokenInfo(ctx context.Context, mintAddress solana.PublicKey) (*x402types.TokenInfo, error) {
	// Get mint account info
	accountInfo, err := c.client.GetAccountInfo(ctx, mintAddress)
	if err != nil {
		return nil, fmt.Errorf("failed to get mint account: %w", err)
	}
	
	if accountInfo == nil || accountInfo.Value == nil {
		return nil, fmt.Errorf("mint account not found")
	}
	
	// Decode mint data
	mintData := accountInfo.Value.Data.GetBinary()
	if len(mintData) < 44 { // Minimum size for mint account
		return nil, fmt.Errorf("invalid mint data size")
	}
	
	// Parse decimals (at offset 44)
	decimals := uint8(mintData[44])
	
	return &x402types.TokenInfo{
		Standard: x402types.TokenStandardSPL,
		Address:  mintAddress.String(),
		Decimals: int(decimals),
		ChainID:  c.getChainID(),
	}, nil
}

// getOrCreateTokenAccount gets or creates a token account for the given owner and mint
func (c *SolanaClient) getOrCreateTokenAccount(
	ctx context.Context,
	owner solana.PublicKey,
	mint solana.PublicKey,
) (solana.PublicKey, error) {
	// Find existing token account
	tokenAccounts, err := c.client.GetTokenAccountsByOwner(
		ctx,
		owner,
		&rpc.GetTokenAccountsConfig{
			Mint: &mint,
		},
		&rpc.GetTokenAccountsOpts{
			Commitment: c.commitment,
		},
	)
	if err != nil {
		return solana.PublicKey{}, fmt.Errorf("failed to get token accounts: %w", err)
	}
	
	if len(tokenAccounts.Value) > 0 {
		// Return existing account
		return tokenAccounts.Value[0].Pubkey, nil
	}
	
	// Create associated token account address
	associatedAccount, _, err := solana.FindAssociatedTokenAddress(owner, mint)
	if err != nil {
		return solana.PublicKey{}, fmt.Errorf("failed to find associated token account: %w", err)
	}
	
	return associatedAccount, nil
}

// GetBalance retrieves the balance of an address for a specific token
func (c *SolanaClient) GetBalance(ctx context.Context, address solana.PublicKey, mint *solana.PublicKey) (uint64, error) {
	if mint != nil {
		// SPL token balance
		tokenAccounts, err := c.client.GetTokenAccountsByOwner(
			ctx,
			address,
			&rpc.GetTokenAccountsConfig{
				Mint: mint,
			},
			&rpc.GetTokenAccountsOpts{
				Commitment: c.commitment,
			},
		)
		if err != nil {
			return 0, fmt.Errorf("failed to get token accounts: %w", err)
		}
		
		var totalBalance uint64
		for _, account := range tokenAccounts.Value {
			totalBalance += account.Account.Data.GetParsed().Amount
		}
		
		return totalBalance, nil
	} else {
		// Native SOL balance
		balance, err := c.client.GetBalance(ctx, address, c.commitment)
		if err != nil {
			return 0, fmt.Errorf("failed to get SOL balance: %w", err)
		}
		
		return balance.Value, nil
	}
}

// Close closes the client connections
func (c *SolanaClient) Close() {
	if c.wsClient != nil {
		c.wsClient.Close()
	}
}

// GetNetwork returns the network this client is connected to
func (c *SolanaClient) GetNetwork() x402types.Network {
	return c.network
}

// getChainID returns a chain identifier for Solana networks
func (c *SolanaClient) getChainID() string {
	switch c.network {
	case x402types.NetworkSolanaMainnet:
		return "mainnet-beta"
	case x402types.NetworkSolanaDevnet:
		return "devnet"
	default:
		return "unknown"
	}
}